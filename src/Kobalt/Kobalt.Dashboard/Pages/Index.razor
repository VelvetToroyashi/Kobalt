@page "/"
@using MudBlazor.Services
@implements IAsyncDisposable

<MudLayout>
    <MudContainer Class="mt-5" MaxWidth="@_maxWidth">
        <MudText Align="Align.Center" Typo="Typo.h2">Kobalt.</MudText>
        <MudDivider/>
        <MudText Align="Align.Center" Typo="Typo.h6">The Discord bot to serve <span style="text-decoration: underline;">you.</span></MudText>
    
        <MudHidden Breakpoint="Breakpoint.SmAndDown">
            <div class="mt-6"/>
        </MudHidden>
        
        <MudGrid Justify="Justify.SpaceBetween" Class="feature-grid gap-4" Style="min-width: fit-content;">
            <MudItem xs="12" sm="6"  Class="feature-card flex flex-shrink flex-col">
                <MudPaper Class="pb-4">
                    <MudImage Src="img/mute_example.png" Height="150"/>
                    <div class="mt-3"/>
                    <MudContainer>
                        <MudText Class="mb-3" Typo="Typo.h5">Comprehensive logging.</MudText>
                        
                        <MudText Typo="Typo.body2">
                            Logging should be expressive, yet concise.
                            Kobalt tells you what's important, by default.
                        </MudText>
                    </MudContainer>
                </MudPaper>
            </MudItem>

            <MudItem xs="12" sm="5" Class="feature-card flex flex-shrink flex-col">
                <MudPaper Class="pb-4">
                    <MudImage Src="img/artist_verification_example.png" Height="150"/>
                    <div class="mt-3"/>

                    <MudContainer>
                        <MudText Class="mb-3" Typo="Typo.h5">Artist Verification</MudText>

                        <MudText Typo="Typo.body2" Style="text-wrap: pretty;">Coming soon&trade;, Kobalt will be able to verify artists.</MudText>
                        <MudText Typo="Typo.body2" Style="text-wrap: pretty;">
                            Artists must opt-in for automatic verification, but
                            Kobalt also offers a robust lookup system to use.
                        </MudText>
                    </MudContainer>
                </MudPaper>
            </MudItem>

            <MudItem xs="12" Class="feature-card">
                <MudPaper Class="pb-4">
                    <MudContainer>
                        <MudText Class="mb-3" Typo="Typo.h5">Dynamic auto-moderation.</MudText>
                        
                        <MudText Typo="Typo.body2" Style="text-wrap: pretty;">
                            Running a server is tricky business. Kobalt can take some of the work
                            off your hands by providing automated tooling to deal with repeat-offenders,
                            compromised/spam accounts, raiders, and more.
                        </MudText>
                    </MudContainer>
                </MudPaper>
            </MudItem>
        </MudGrid>
    </MudContainer>
</MudLayout>

<MudHidden Breakpoint="Breakpoint.MdAndDown">
    <style>
        .feature-card {
            max-width: calc(min(500px, 45vw)) !important;
        }
    </style>
</MudHidden>

<style>
    .feature-grid {
        width: 100%;
        margin: 0;
        padding: 0;
    }
    
    .feature-card {
        padding: 16px 0 !important;
        max-width: 550px;
    }
</style>

@code
{
    [Inject]
    public IBrowserViewportService BreakpointListener { get; set; }
    private MaxWidth _maxWidth;
    
    private readonly Guid _breakpointListenerId = Guid.NewGuid();

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }
        
        await BreakpointListener.SubscribeAsync
        (
            _breakpointListenerId,
            breakpointArgs =>
            {
                _maxWidth = breakpointArgs.Breakpoint <= Breakpoint.Md ? MaxWidth.Large : MaxWidth.Medium ;
                return Task.CompletedTask;
            }, 
            new ResizeOptions
            {
                ReportRate = 250,
                NotifyOnBreakpointOnly = true,
            }
        );

        await base.OnAfterRenderAsync(firstRender);
    }

    public async ValueTask DisposeAsync() => await BreakpointListener.UnsubscribeAsync(_breakpointListenerId);
}
